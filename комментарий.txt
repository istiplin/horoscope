	1) Написан php скрипт, который выводит на экран пользователей, с постраничной разбивкой (по 20 пользователей).
Файл index.php содержить представление, в нем же подгружаются классы, которые можно отнести к модели.
Сначала использовался один класс, но из-за 5-ого пункта, где надо было создать таблицу гороскопов, 
которая содержит прогнозы, было принято решение использовать 2 класса:
Pagination - содержит информацию, конкретно, о текущей странице и, в общем, о всех страницах, также он может выводить эту информацию в виде представления,
по которому можно преходить по страницам.
CapricornData - данные о пользователях со знаком зодиака «козерог».
Оба класса зависят друг от друга: 
	- сначала класс CapricornData передает количество всех пользователей классу Pagination,
	- затем класс Pagination передает скорректированную текущую страницу и размер страницы классу CapricornData, для вывода данных на экран.
	
Ну а в общем, класс Pagination зависит от CapricornData (а точнее от абстрактного класса Data), а не наоборот, т.к. классу Pagination
нужно было преобразовывать некоторорые данные, из-за, переданного ему, количества всех записей (пользователей).
Ну а классу CapricornData данные от Pagination нужны только для вывода списка на экран.

	Перед этим была создана база в MySQL horoscope.sql. Там была создана хранимая функция beetween_date, которая определяет,
попадает ли дата в формате yyyy-mm-dd (например: 198012-26, 1920-07-16 и т.д.) между датами, в формате mm-dd (12-26, 07-16 и т.д.).
Благодаря этой функции можно вывести пользователей со знаком зодиака «козерог».

	2) Таблицы были дополнены индексами:
	 - в таблице user в поле s_login добавлен уникальный индех, т.к. логины не могут повторяться.
	 - в таблице user_field в поле s_field_path добавлен уникальный индех, т.к. наименования полей не могут повторяться.
	 - в таблице user_field_value в поле t_value был добавлен полнотекстовый поиск.

	3) Из-за того, что в таблицу user_field_value был добавлен полнотекстовый поиск, данные будут храниться в двойном объеме,
что не очень хорошо для большого количества записей. Также при добавлении, удалении и обновлении записей, 
запросы будут идти в дополнительную таблицу что может увеличить нагрузку на сервер.
	Также поле t_value имеет текстовый формат, т.е. тип данных не контролируется. Из-за этого для i_fld_id=1 можно записать не только дату рожения.
	Дополнительные поля таблицы user хранятся в отдельных таблицах, из-за этого нужно постоянно делать запросы join, которые работают дольше.
	
	4) На реализацию задачи суммарно ушло, примерно, 11 часов. Постоянный рефакторинг кода, внезапное обнаружение некоторых ошибок,
поиск новых путей для решения проблем, увеличило время на реализацию задачи.

	5) Была создана новая таблица prediction, что означает прогноз. Таблица состоит из 3-х полей:
1. d_date - означает дату прогноза
2. i_zodiac_id - означает id знака зодиака, условился, что id=1 соответствует знаку зодиака «козерог».
3. t_text - текст, где хранится информация о прогнозе, таким образом, зная дату и id знака зодиака, 
можно определить прогноз человека с этим знаком в определенное время.
	В этой таблице был создан уникальный индекс из полей (d_date, i_zodiac_id) причем d_date идет первым,
т.к. в ней меньше повторяющихся записей, чем в i_zodiac_id.

	В продолжении п.1 хотел сказать, что из-за 5-ого пункта появилась идея переписать код. Для вывода таблицы прогнозов,
используется класс PredictionData. Классы PredictionData и CapricornData имеют общего родителя - абстрактный класс Data.
Класс Pagination зависит от класса Data.